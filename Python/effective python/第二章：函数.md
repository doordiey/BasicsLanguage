# 函数

>   在python中一个有用的工具就是函数。和别的程序语言中一样，函数可以使你将一个大的项目分散成小的简单的各个部分。这使得你的代码变得更加容易阅读。能更好的进行代码复用和重构。
>
>   在python中函数有很多额外的特性使得你的程序变得更简单。有一些别的语言也有的，有的是python所特有的。这些额外的特性使得函数的目的更加明显。  这样可以使在调用函数时十分容易的知道函数是在做什么。在查找bug时也变得更加容易。

## 项目14： 返回异常而不是返回None

  当编写实用程序函数时，python程序员总是会将返回None值有一些特殊的含义。这在一些情况下是很有用的。举个例子，如果你想要用一个辅助函数去计算除法运算。那么假设除数为0时返回None是正常的。

```python
def divide(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        return None
```

  这样编写代课可以相应的解释其返回值。

```python
result = divide(x, y)
if result is None:
    print('Invalid inputs')
```

  当分子为0的时候会发生什么？这会导致返回值也为0.当你在if的语句下进行判断时，可能会导致问题。你可能会得到一些其它的为False的判断，而不是只寻找none的情况,如下：

```python
x, y =0, 5
result = divide(x, y)
if not result:
    print('Invalid inputs')
```

  当None是有特殊含义时，这样的写法在python代码中是一个常见的错误。这就是为什么从一个函数中返回none是一个容易出现错误原因。有两个方法可以去减少类似这样的错误。

  第一个方法是将返回的值变成一个含有两个值的元组。第一部分是标识操作是成功的还是失败的。第二部分是他实际的计算结果。

```python 
def divide(a, b):
    try:
        return True, a / b
    except ZeroDivisionError:
        return False, None
```

  调用这个函数后需要分析返回的元组，这就使得在得到结论时不光要看除法得结果还要看元组的撞他部分。

```python
success, resule = divide(x, y)
if not success:
    print('Invalid')
```

  这个问题在于调用者容易忽略返回元组的第一部分，如下面所示，咋一眼看上去没有什么问题，然而它实际上是错误的。

```python
_,result = divide(x, y)
if not result:
    print('Invalid')
```

  第二个方法会处理的更好一些，它不返None,而实返回一个异常出去，让调用函数保护的人去处理它。

```python
def divide(a, b):
    try:
        return True, a / b
    except ZeroDivisionError as e:
        return ValueError('Invalid ') from e
```

  用这样的方法的话，调用者就必须要处理非法输入的情况。下面的例子可以清晰的看到调用函数的人的处理。

```python
x, y = 5, 2
try:
    result = divide(x, y)
except ValueError:
    print('Invalid')
else:
    print(result)
```

### 一些需要记住的事情

- 当函数返回None是具有特殊含义的话，在返回进行逻辑判断是否为None时可能会被一些其它的逻辑判断为False的值干扰。
- 引发异常以指示特殊情况，而不是返回None。记录下来后，期望调用代码能够正确处理异常。

## 项目15：了解闭包如何与变量作用域相互影响

  假设你要对数字列表进行排序，但要优先考虑一组数字得排在前面。这种情况的话你可以使用此模式。一个常用的情况是将一个关键字传到辅助函数中作为列表排序的方式。辅助函数的返回值将会被用在搜索的每一项内。辅助函数会检查所给的元素是否是重要组里的内容从而正确排序。

```python
def sort_proprity(values, group):
    def helper(x):
        if x in group:
            return (0, x)
       	return (1, x)
    value.sort(key=helper)
```

  这个函数在处理接到那的输入的时候是有效的。

```python
numbers = [8, 3, 1, 2, 5, 4, 7, 6]
group = {2, 3, 5, 7}
sort_proprity(numbers, group)
print(numbers)
```

  这样的写法能达到需求有三个原因：

- python支持闭包：函数可以从定义的范围内引用变量。这就使得上例中helper函数可以访问sort_proprit的group参数。
- 函数是python的一类对象，这意味着你可以直接的引用它们，将它分配给变量，并且可以作为参数，可以和if语句进行比较。所以上例中的sort函数可以接收help函数作为参数。
- 函数在进行比较元组时有特定的规则。它首先比较索引为0的项目，然后是1，以此类推。这就是上例中可以靠返回值导致排序顺序不同的原因。

  如果这个函数还能返回是否可以有优先级较高的项目就更好了。为了实现这个功能。现在已经有了一个闭包函数去确定每个元素属于的组了。那么我们可以试试在闭包函数中加上一个标志，然后返回这个标值。

```python
def sort_priority2(numbers, group):
    found = False
    def helper(x):
        if x in group:
            found = True
            return (0, x)
        return(1,x)
    numbers.sort(key=helper)
    return found
```

  使用和之前一样的输入，然后得到的结果却是错误的。明明numbers内有属于group的元素，但返回值缺失false，这是为什么呢？当你在表达式内引用变量时，python解释器将遍历作用域按下面这个顺序解析引用：

1.当前函数的作用域

2.封闭范围内

3.全局作用域【global bariable

4.内置函数作用域

  如果这些地方都没有找到引用变量的名称时，会抛出一个NameError。

  将值分配给变量的工作方式不同。如果变量已经在当前值被定义了，那么它会被替换成一个新的值;如果该变量并不存在于当前变量，那么将其看作新变量定义。新定义的变量的范围时被赋值的该函数内。

  这就能够解释上面能够例子的错误了，定义为True值的`found`变量仅在helper闭包内有效，不会用`sort_priority2`内定义的变量。

  这种问题被称为范围界定错误，这对新手来说是十分让人惊讶的。但这就是其运行的结果，这样的行为可以防止函数中的局部变量污染包含它的模块，如果不这样做的话，函数中的每个分配都会将一些不必要的垃圾放进全局范围内。这样就容易导致一些其它的bug。

### 将数据取出来

  在python3中，想要取出一个闭包内的数据的话有一种特殊的语法。`nonlocal`用于指示在遍历特定遍历名称时应进行范围遍历，但其并不会遍历模块级别的范围。

  下面用`nonlocal`来改进一下之前的代码：

```python
def sort_priority(numbers, group):
    found = False
    def helper(x):
        nonlocal found
        if x in group:
            found = True
            return (0, x)
        return(1,x)
    numbers.sort(key=helper)
    return found
```

  使用`nonlocal`语句使得数据能从闭包分到到另一个变量。它是对`global`语句的补充，后者表示变量的分配应直接进行模块范围。

  然而，这就像全局变量的反模式一样，我警告不要讲`nonlocal`用于处理简单函数以外的任何事物之中。`nonlocal`的副作用很难理解，尤其是在长函数中，非局部语句和关联变量的分配相差很多。

  当你使用`nonlocal`变得复杂的时候，最好将你的状态包装成一个辅助类。下面举例将上面的包装成一个类。

```python
class Sorter(object):
    def __init__(self, group):
        self.group = group
        self.round = False
    def __call__(self, x):
        if x in self.group:
            self.found = True
            return (0, x)
        return (1, x)
    
sorter = Sorter(group)
numbers.sort(key=sorter)
assert sort.found is True
```

### python2 中的范围

  不幸的是，python2并不支持`nonlocal`。为了有类似的处理，你就必须利用好python的范围规则。这种方法并不够漂亮，但是常见的python习惯用法。

```python
def sort_priority(numbers, group):
    found = [False]
    def helper(x):
        nonlocal found
        if x in group:
            found[0] = True
            return (0, x)
        return(1,x)
    numbers.sort(key=helper)
    return found[0]
```

  将found的值变成一个可变的列表，就意味着一旦检索到就可以将修改的状态发送到内部范围之外。当御用遍历作用域的变量是定义的字典、集合或者类的实例的时候，都是可行的。

### 一些需要记住的事情

- 闭包函数可以从定义它们的任何范围中引用变量
- 默认情况下，闭包不会通过分配变量来影响范围。
- 在python3中，使用nonlocal来处理闭包想要修改范围外的变量
- 在python2中，欸有Nonlocal,使用一个可变的值来修改。
- 除了简单函数外的任何情况都要避免使用`nonlocal`

## 项目16： 考虑返回生成器而不是返回列表

  对于函数返回一个结果序列的一个简单实现就是返回一个元素的列表。举个例子，如果你想要找到一个字符串中每个单词的索引。可以使用append方法将结果累积在列表中，并返回结果列表。

```python
def index_words(text):
    result = []
    if text:
        result.append(0)
    for index, letter in enumerate(text):
        if letter == ' ':
            result.append(index + 1)
    return result
```

  这种写法对于一些简单的输入是十分有效的。

  然而这个函数中有两个问题：

  第一个问题是代码有些冗杂。每一次找到一个新的结果就要调用append方法。一行用于创建结果列表，另外一行用于返回结果。

  一个更好的解决方法是使用生成器，利用生成器中`yield`的表达。

```python
def index_words_iter(text):
    if text:
        yield 0
    for index, letter in enumerate(text):
        if letter == " ":
            tield index + 1
result = list(index_words_iter(address))
```

  第二个问题是返回列表的话就意味着要存储所有的值。对于一个大的输入来说，会很浪费，影响性能。返回生成器可以有效的避免这个问题。

### 一些需要记住的事情

- 返回生成器比返回计算结果的列表更清晰简洁
- 生成器可以避免处理大数据输入时的浪费内存

