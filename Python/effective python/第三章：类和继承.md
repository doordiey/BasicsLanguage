# 类和继承

  python作为一个面向对象程序语言，它支持一系列特性，诸如封装、继承、多态。在python中通常通过写新的类和定义他们之间的接口和层次结构进行交互来完成工作。

  python的类和继承使得程序在对象上的额外表现变得简单。它们使得你可以随着时间得推移不断地改进和扩展功能。在变化地需求中提供灵活性。了解如果使用好它们可以使你写出可维护地代码。

### 项目22：提供辅助类而不是使用字典和元组进行薄记

  python地内置字典类型非常适合在对象生命周期内保持动态内部状态。我所提的动态是指你需要记录一些你意料之外的一系列标识的情况。举个例子，你想要记录一个学生的成绩，但你并不知道他的名字。你可以定义一个类去将名字记录在字典内，而不是给每个学生预定义一个属性。

```python
class SimpleFradebook(object):
    def __init__(self):
        self._grades = {}

    def add_student(self, name):
        self._grades[name] = []

    def report_grade(self, name, score):
        self._grades[name].append(score)
        
    def avergae_grade(self, name):
        grades = self._grades[name]
        return sum(grades) / len(grades)

book = SimpleFradebook()
book.add_student('ycp')
book.report_grade('ycp', 100)
print(book.avergae_grade('ycp'))
        
```

  按上面的代码可以基本实现要求的功能，但是由于字典太易于使用了，以至于它存在过度扩展以编写易碎代码的危险。举个例子，如果你想要扩展这个类，使得可以不光保存分数，还保存其科目。

改进如下：

```python
class SubjectGradebook(object):
    def __init__(self):
        self._grades = {}

    def add_student(self, name):
        self._grades[name] = {}

    def report_grade(self, name, subject, score):
        by_subject = self._grades[name]
        grade_list = by_subject.setdefault(subject, [])
        grade_list.append(score)

    def avergae_grade(self, name):
        by_subject = self._grades[name]
        total, count = 0, 0
        for grades in by_subject.values():
            total += sum(grades)
            count += len(grades)
        return total / count

book = SubjectGradebook()
book.add_student('ycp')
book.report_grade('ycp', 'it', 100)
book.report_grade('ycp', 'math', 80)
book.report_grade('ycp', 'english', 30)
print(book.avergae_grade('ycp'))
```

  这样又改出了符合需求的代码，但是如果这个时候需求又发生了变化，又要求给不同的考试以不同的权重。这种情况下当然你可以继续去修改类里面的字典让它变得符合要求，但显然代码会变得复杂，不易懂，连调用也变得困难了，进行维护的话就更是一场噩梦了。

  一旦你发现薄记变得越来越复杂了，那就就将它分为机类，这样就可以提供定义明确的接口，能更好的对数据进行封装。能使你在接口和具体实现之间创建抽象层。

### 重构成类

  你可以将在依赖关系树底部的类进行移动：权重等级。对于这个简单的信息来说，使用一个类似乎没有必要。由于等级是不可变的，我们可以使用元组来。

``` python
grades = []
grades.append((95, 0.45))
total = sum(score * weight for score, weight in grades)
total_weight = sum(weight for _,weight in grades)
average_grade = total / total_weight
```

  这个问题在于普通元组是有位置的，如果你想要更多的有关信息，就需要重写捕获元组的每个项的部分。随着信息的增多会导致元组的长度越来越长，超过了两个元组，我们就需要考虑别的办法了。

  集合模块重的`namedtuple`类型可以满足这个需求，它使得我们定义微小、不变的数据变得简单。

```python
import collections
Grade = collections.namedtuple('Grade', ('score', 'weight'))
```

  可以使用位置或关键字参数构造这些类。命名属性的使用使得当需求发生改变，你想要在你的类后面添加新的元组变得十分轻松。

#### namedtuple 的限制

  虽然它有些时候有很不错的表现，但是它也有它的问题。

- 你无法为`namedtuple`类指定默认参数值。当你的数据可能有很多的可选属性的时候，就会显得十分笨拙。
- `namedtuple`实例的属性值可以通过数字索引和迭代进行访问，这可能会导致无意使用。所以，如果你不能控制好它的所有用法，最好还是定义自己的类。

  下面，将原来的拆分成各个类

```python
import collections


class Subject(object):
    def __init__(self):
        self._grades = []

    def report_grade(self, score, weight):
        Grade = collections.namedtuple('Grade', ('score', 'weight'))
        self._grades.append(Grade(score, weight))

    def average_grade(self):
        total, total_weight =0, 0
        for grade in self._grades:
            total += grade.score * grade.weight
            total_weight += grade.weight
        return total / total_weight


class Student(object):
    def __init__(self):
        self._subjects = {}

    def subject(self, name):
        if name not in self._subjects:
            self._subjects[name] = Subject()
        return self._subjects[name]

    def average_grade(self):
        total, count = 0, 0
        for subject in self._subjects:
            total += subject.average_grade()
            count += 1
        return total / count


class Gradebook(object):
    def __init__(self):
        self._student = {}

    def student(self, name):
        if name not in self._student:
            self._student[name] = Student()
        return self._student[name]

```

### 一些需要记住的事情

- 避免使用具有多层结构的字典及其长元组值的字典
- 使用`namedtuple`作为轻型、不变的数据容器
- 当使用字典的结构变得复杂的时候，通过改用多个辅助类的方式

