# go相关基础

> 首先，友好的打招呼

``` go
package main
import "fmt"
func main(){
	fmt.Print("hello,world")
}
```

## 包、函数、变量、基本类型

### 包

> 每个go程序都由包构成

#### 导入形式

> 两种形式都可以，但使用分组导入是更好的形式

- 使用圆括号的分组导入

  ``` go
  import (
  	"fmt",
      "math"
  )
  ```

- 编写多个导入语句

```go
import "fmt"
import "math"
```

#### 导出名

> 在go中，如果一个名字以大写字母开头，那么它就是已导出的。导入一个包时，只能引用已导出的名字，任何未导出的名字在该包外均无法访问。

- 错误示例

``` go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)//此处 pi应为Pi
}

```

### 函数

#### 参数方面

> 可以没有参数或接收多个参数：参数的类型在变量名之后，当连续两个或多个函数的已命名形参类型相同，除最后一个类型外，其它的可以省略

```go
package main
import "fmt"

func add(a int, b int, c int) int{  //此处可以缩写为:func add(a,b,c int) int{}
	return a+b+c
}

func main(){
	fmt.Print(add(1,2,3))
}
```

#### 多值返回

> 可以返回任意数量的返回值

``` go
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world") //此处接收了两个返回值
	fmt.Println(a, b)
}
```

##### 返回值命名

> 返回值命名可以定义在函数顶部的变量，没有参数的return 返回已命名的返回值

- 短函数中适用，长的函数会影响代码的可读性

```go
package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}
```

### 变量

> 适用var 语句声明变量列表，和函数的参数列表一样，类型在最后面，可以出现在包或函数级别

```go
package main

import "fmt"

var c, python, java bool

func main() {
	var i int
	fmt.Println(i, c, python, java)
}
//输出：0 false false false
```

- 提问：若同一变量名，在包级别和函数级别被定义了不同类型听谁的。
  - 例子解答：输出按函数级别内的定义

```go

import "fmt"

var c, python, java bool

func main() {
	var i,c int
	fmt.Println(i, c, python, java)
}
//输出：0 0 false false
```

#### 变量初始化

> 声明时可以包含初始值，如果初始化值已存在，可以省略类型

``` go
package main

import "fmt"

var i, j int = 1, 2

func main() {
	var c, python, java = true, false, "no!"
	fmt.Println(i, j, c, python, java)
}
//输出：1 2 true false no!
```

- 多个变量，是否也可以使用类似分组导入的形式？
  - 示例说明：可以

```go
package main

import "fmt"

var (
	i, j      int    = 1, 2
	c, python bool   = true, false
	java      string = "no!"
)

func main() {
	fmt.Println(i, j, c, python, java)
}
```

####  短变量说明

>  可用`:=`在类型明确的地方代替`var`声明，函数外的每个语句都必须以关键字开始，因此:=不能再函数外使用

- 提问：`:=`与`var`的区别？【除了:=不能在函数外使用以外还有什么区别
  - 暂时没有，似乎就是因为:=比var简洁吧？

### 基本类型

bool string int int8 int32 int16 int64

uint uint8 uint16 uint32 uint64 uintptr

byte // uint8的别名

rune // int32的别名

float32 float64

complex64	complex 128

- int,uint,uintptr在32位系统上通常为32位宽，在64位系统上则为64位宽
- 除非有特殊的理由要使用固定大小或无符号的整数类型

```go
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe   bool       = false
	MaxInt uint64     = 1<<64 - 1
	z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
	fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
	fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value: %v\n", z, z)
}
//输出：
//Type: bool Value: false
//Type: uint64 Value: 18446744073709551615
//Type: complex128 Value: (2+3i)
```

#### 零值

> 没有明确的初始值的变量就是被赋予默认零值

- 从前面的例子可以看出来了。

#### 类型转换

> 使用`T(v)`的形式将值`v`转换为类型`T`

```go
package main

import (
	"fmt"
	"math"
)

func main() {
	var x, y int = 3, 4
	var f float64 = math.Sqrt(float64(x*x + y*y))
	var z uint = f //这种情况下报错，f为float64类型，无法赋值
	fmt.Println(x, y, z)
}
```

#### 类型推导

在声明一个变量而不指定类型时，其类型由右值推导得出

- 右值声明了类型的话，新变量的类型与其相同
- 右值是未指明类型的数值常量时，取决于常量的精度

```go
package main

import "fmt"

func main() {
	v := 42 // 修改此处的值查看类型变化！
	fmt.Printf("v is of type %T\n", v)
}
```

#### 常量

> 声明与变量类似，用的是`const`关键字，不能用`:=`语法声明

- 常量：定义后无法修改
- 提问：常量的设计在编程语言设计的作用是？-
  - 第一个想到的是性能方面
  - 安全？防止自己不定时犯蠢？【也是相对的，可能后面又想修改了呢

#### 数值常量

> 一个未指定类型的常量由上下文来决定其类型

```go
package main

import "fmt"

const (
	Big = 1 << 100 //将1进行左移动，二进制
	Small = Big >> 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x * 0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}
//输出
//21
//0.2
//1.2676506002282295e+29
```

